(let $camlTests15__immstring13 = "tests15.ml" in
 let $camlTests15__const_block15 = Block 0 ($camlTests15__immstring13, 2, 52)
 in
 let $camlTests15__Pmakeblock18 =
   Block 0 ($`*predef*`.caml_exn_Assert_failure, $camlTests15__const_block15)
 in
 let $camlTests15__empty_array20 = Empty_array in
 let code size(20)
       list_to_array_0 (param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : any array =
   let next_depth = rec_info (succ my_depth) in
   (let prim = %is_int param in
    let Pisint = %Tag_imm prim in
    (let untagged = %untag_imm Pisint in
     switch untagged
       | 0 -> k5
       | 1 -> k6)
      where k6 =
        cont k3
      where k5 =
        cont k4)
     where k4 =
       cont k2 pop(regular k2) ($camlTests15__Pmakeblock18)
     where k3 =
       cont k1 ($camlTests15__empty_array20)
 in
 let code size(18)
       is_c_1
         (x,
          param :
            [ 0 of imm tagged |1 of imm tagged |2 of imm tagged
            |3 of imm tagged ])
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   (let prim = %get_tag param in
    let scrutinee_tag = %Tag_imm prim in
    let untagged = %untag_imm scrutinee_tag in
    let eq = %int_comp imm untagged = 2i in
    switch eq
      | 0 -> k3
      | 1 -> k1 (1))
     where k3 =
       cont k1 (0)
 in
 let code size(6)
       set_to_x_2 (b : val, i : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let prim = %untag_imm 120 in
   let prim_1 = %num_conv (imm tagged -> imm) i in
   let Pbytessetu = %bytes_set 8 b.(prim_1) prim in
   cont k1 (Pbytessetu)
 in
 let code size(3)
       classical_id_3 (b : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let Pnot = %not b in
   let Pnot_1 = %not Pnot in
   cont k1 (Pnot_1)
 in
 let code size(8)
       swapped_4 (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let int_bswap = %int_arith bswap 287454020 in
   cont k1 (int_bswap)
 in
 let code size(3)
       negate_5 (x : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let int_neg = 0 - x in
   cont k1 (int_neg)
 in
 let code size(2)
       foo_6 (x : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let int_or = x lor 42 in
   cont k1 (int_or)
 in
 let $camlTests15__immstring61 = " \\ \n " in
 let list_to_array = closure list_to_array_0 @list_to_array in
 let is_c = closure is_c_1 @is_c in
 let set_to_x = closure set_to_x_2 @set_to_x in
 let classical_id = closure classical_id_3 @classical_id in
 let swapped = closure swapped_4 @swapped in
 let negate = closure negate_5 @negate in
 let foo = closure foo_6 @foo in
 let Pmakeblock =
   %Block 0
     (list_to_array,
      is_c,
      set_to_x,
      classical_id,
      swapped,
      negate,
      $camlTests15__immstring61,
      foo)
 in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load tag(0) size(8) (0) module_block in
    let field_1 = %block_load tag(0) size(8) (1) module_block in
    let field_2 = %block_load tag(0) size(8) (2) module_block in
    let field_3 = %block_load tag(0) size(8) (3) module_block in
    let field_4 = %block_load tag(0) size(8) (4) module_block in
    let field_5 = %block_load tag(0) size(8) (5) module_block in
    let field_6 = $camlTests15__immstring61 in
    let field_7 = %block_load tag(0) size(8) (7) module_block in
    let $camlTests15 =
      Block 0 (field_0,
               field_1,
               field_2,
               field_3,
               field_4,
               field_5,
               field_6,
               field_7)
    in
    cont done ($camlTests15)
===>
let $camlTests15__immstring13 = "tests15.ml" in
let $camlTests15__const_block15 = Block 0 ($camlTests15__immstring13, 2, 52)
in
let $camlTests15__Pmakeblock18 =
  Block 0 ($`*predef*`.caml_exn_Assert_failure, $camlTests15__const_block15)
in
let $camlTests15__empty_array20 = Empty_array in
let code list_to_array_0 deleted in
let code is_c_1 deleted in
let code set_to_x_2 deleted in
let code classical_id_3 deleted in
let code swapped_4 deleted in
let code negate_5 deleted in
let code foo_6 deleted in
let $camlTests15__immstring61 = " \\ \n " in
let code loopify(never) size(11) newer_version_of(list_to_array_0)
      list_to_array_0_1 (param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : any array =
  let prim = %is_int param in
  switch prim
    | 0 -> k1 pop(regular k1) ($camlTests15__Pmakeblock18)
    | 1 -> k ($camlTests15__empty_array20)
in
let $camlTests15__list_to_array_7 = closure list_to_array_0_1 @list_to_array
in
let code loopify(never) size(6) newer_version_of(is_c_1)
      is_c_1_1
        (x,
         param :
           [ 0 of imm tagged |1 of imm tagged |2 of imm tagged
           |3 of imm tagged ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %get_tag param in
  let eq = %int_comp imm prim = 2i in
  let tagged_scrutinee = %Tag_imm eq in
  cont k (tagged_scrutinee)
in
let $camlTests15__is_c_8 = closure is_c_1_1 @is_c in
let code loopify(never) size(5) newer_version_of(set_to_x_2)
      set_to_x_2_1 (b : val, i : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %num_conv (imm tagged -> imm) i in
  let Pbytessetu = %bytes_set 8 b.(prim) 120i in
  cont k (0)
in
let $camlTests15__set_to_x_9 = closure set_to_x_2_1 @set_to_x in
let code loopify(never) size(3) newer_version_of(classical_id_3)
      classical_id_3_1 (b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let Pnot = %not b in
  let Pnot_1 = %not Pnot in
  cont k (Pnot_1)
in
let $camlTests15__classical_id_10 = closure classical_id_3_1 @classical_id in
let code loopify(never) size(1) newer_version_of(swapped_4)
      swapped_4_1 (param : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont k (17459)
in
let $camlTests15__swapped_11 = closure swapped_4_1 @swapped in
let code loopify(never) size(3) newer_version_of(negate_5)
      negate_5_1 (x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let int_neg = 0 - x in
  cont k (int_neg)
in
let $camlTests15__negate_12 = closure negate_5_1 @negate in
let code loopify(never) size(2) newer_version_of(foo_6)
      foo_6_1 (x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let int_or = x lor 42 in
  cont k (int_or)
in
let $camlTests15__foo_13 = closure foo_6_1 @foo in
let $camlTests15 =
  Block 0 ($camlTests15__list_to_array_7,
           $camlTests15__is_c_8,
           $camlTests15__set_to_x_9,
           $camlTests15__classical_id_10,
           $camlTests15__swapped_11,
           $camlTests15__negate_12,
           $camlTests15__immstring61,
           $camlTests15__foo_13)
in
cont done ($camlTests15)
